## 音乐宏定义解析文档

本文档描述了 `sound.s` 汇编代码中音乐事件宏的解析方式。这些宏定义（例如 `D(x)`, `X(c)`, `N(c,n)`, `M(c,n,v)`）用于生成一个字节序列，该序列随后由 `sound.s` 生成的汇编代码中的 `midi_tick` 和 `midi_note` 例程进行解释和执行。

### 宏定义概览

以下是用户提供的宏定义及其预期功能：

*   [`#define D(x) x`](sound.s:208) `/* wait x frames */`
    *   功能：等待 `x` 帧。
    *   生成字节：一个字节 `x`。
*   [`#define X(c) 127+(c)`](sound.s:215) `/* channel c off */`
    *   功能：关闭通道 `c` 上的音符。
    *   生成字节：一个字节 `127 + c`。
*   [`#define N(c,n) 143+(c),(n)`](sound.s:220) `/* channel c on, note=n */`
    *   功能：在通道 `c` 上播放音符 `n`。
    *   生成字节：两个字节：`143 + c`，然后是 `n`。
*   [`#define M(c,n,v) 159+(c),(n),(v)`](sound.s:186) `/* channel c on, note=n, wavA=v */`
    *   功能：在通道 `c` 上播放音符 `n`，并设置音量 `v`。
    *   生成字节：三个字节：`159 + c`，然后是 `n`，然后是 `v`。
    *   **注意**：宏定义中的注释 `wavA=v` 可能与实际汇编代码的实现不符。根据 `sound.s` 中的代码，`v` 被解析为音量（`0xfa` 寄存器），而不是波形（波形寄存器为 `0xfb`）。

### 解析流程 (`midi_tick` 和 `midi_note`)

`midi_tick` 例程负责从 MIDI 数据流中读取命令字节并根据其值进行分派。`midi_note` 例程则处理音符开启事件。

1.  **获取命令字节** ([`sound.s:199`](sound.s:199)-[`sound.s:205`](sound.s:205))
    *   `midi_tick` 从 `_midi.p` 指向的内存位置读取一个字节作为当前命令。
    *   `_midi.p` 会自动递增以指向下一个字节。
    *   如果读取的字节为 `0`，则检查 `_midi.q` 以获取下一个 MIDI 数据块的地址。

2.  **提取通道信息** ([`sound.s:206`](sound.s:206))
    *   `_midi.cmd`（当前命令字节）的低两位 (`ANDI(3)`) 被提取并存储在 `_midi.tmp+1` 中。这通常表示通道号（0-3）。

3.  **判断命令类型** ([`sound.s:208`](sound.s:208))
    *   通过比较 `_midi.cmd` 的值来确定命令类型：
        *   `_midi.cmd < 0x80` (128) -> 延迟命令 (`D(x)`)
        *   `_midi.cmd >= 0x80` (128) -> 音符控制命令 (`X(c)`, `N(c,n)`, `M(c,n,v)`)

#### 详细解析规则

*   **延迟命令 (`D(x)`)**
    *   **命令字节范围**：`0` 到 `127` (`0x00` 到 `0x7F`)。
    *   **解析**：命令字节 `x` 直接被添加到 `_midi.t`（延迟累加器）中。
    *   **动作**：系统将等待 `x` 帧，然后处理下一个 MIDI 命令。
    *   **汇编代码**：[`sound.s:208`](sound.s:208)-[`sound.s:213`](sound.s:213)

*   **音符关闭命令 (`X(c)`)**
    *   **命令字节范围**：`128` 到 `143` (`0x80` 到 `0x8F`)。
    *   **解析**：通道 `c` 通过 `命令字节 - 127` 获得。
    *   **动作**：将对应通道的频率寄存器 (`0xfc`) 设置为 `0`，从而关闭该通道上的音符。
    *   **汇编代码**：[`sound.s:215`](sound.s:215)-[`sound.s:219`](sound.s:219)

*   **音符开启命令 (`N(c,n)` 或 `M(c,n,v)`)**
    *   **命令字节范围**：`144` 到 `175` (`0x90` 到 `0xAF`)。
    *   **解析**：
        *   **通道 `c`**：
            *   如果命令字节在 `144` 到 `158` (`0x90` 到 `0x9E`) 之间（对应 `N(c,n)`），通道 `c` 通过 `命令字节 - 143` 获得。
            *   如果命令字节在 `159` 到 `174` (`0x9F` 到 `0xAE`) 之间（对应 `M(c,n,v)`），通道 `c` 通过 `命令字节 - 159` 获得。
        *   **音符 `n`**：`midi_note` 例程会从数据流中读取下一个字节作为音符 `n`。
        *   **音量 `v`**：`midi_note` 例程会从数据流中读取再下一个字节作为音量 `v`。这意味着即使是 `N(c,n)` 宏，也期望数据流中紧随音符 `n` 之后有一个音量字节（可能是默认值）。
    *   **动作**：
        *   将音量 `v` 写入对应通道的音量寄存器 (`0xfa`)。
        *   根据音符 `n` 查找 `notesTable` 获取频率值。
        *   将频率值写入对应通道的频率寄存器 (`0xfc`)，从而开启音符。
    *   **汇编代码**：[`sound.s:220`](sound.s:220)-[`sound.s:226`](sound.s:226) (分派到 `midi_note`)，[`sound.s:180`](sound.s:180)-[`sound.s:192`](sound.s:192) (`midi_note` 实际处理)。

### 总结

`sound.s` 中的音乐处理逻辑通过解析一系列字节来驱动，这些字节由高级语言中的宏生成。命令字节的范围决定了其功能（延迟、音符关闭、音符开启），而后续字节则提供音符、音量等参数。值得注意的是，`M(c,n,v)` 宏中的 `v` 在汇编代码中被解释为音量，而不是波形。